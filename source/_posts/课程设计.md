---
title: 课程设计
date: 2021-05-25 19:05:03
categories:	开发
tags: C++
password: 5heeprooo
abstract: 有东西被加密了, 请输入密码查看
message: 这里需要密码
---
> C++结课作业，第一次搞了这么长的代码(虽然巨多bug，还有水行数的嫌疑
> <!--more-->

# 图书馆管理系统
## main.cpp
```
//*****************************图书馆管理系统***********************************
//计算机科学与技术学院/人工智能学院
//162020113 李博轩
#include <iostream>
#include <stdlib.h>
#include <fstream>
#include <cstring>

#include "basic.h"
#include "manage.h"
using namespace std;

int main() {
	cout << "________________________________________________________________________" << endl;
	cout << "|                                                                      |" << endl;
	cout << "|                      欢迎来到NUAA图书馆管理系统			|" << endl;
	cout << "|                                                                      |" << endl;
	cout << "|----------------------------------------------------------------------|" << endl;
	cout << "|                                                                      |" << endl;
	cout << "|                                                                      |" << endl;
	cout << "|               请选择您的身份(学生-S/教师-T/管理-A)			|" << endl;
	cout << "|                                                                      |" << endl;
	cout << "|                                                                      |" << endl;
	cout << "|                                                                      |" << endl;
	cout << "|                                                                      |" << endl;
	cout << "|                                                                      |" << endl;
	cout << "|                                                                      |" << endl;
	cout << "|______________________________________________________________________|" << endl;
	Students student;
	Teachers teacher;
	Manage manager;

	char judge_identity;
	//选择身份
	char judge1;
	//选择注册/登录
	while (1) {
		cout << "请选择身份:\t";
		cin >> judge_identity;
		cin.ignore();
		switch (judge_identity) {
			case 'S': {
				while (1) {
					cout << "注册/登录(R/L):\t";
					cin >> judge1;
					cin.ignore();
					if (judge1 == 'R' || judge1 == 'r')
						student.registered();
					else if (judge1 == 'L' || judge1 == 'l')
						student.login();
					else
						cout << "无效字符! 请重新输入" << endl;
				}
				break;
			}
			case 's': {
				while (1) {
					cout << "注册/登录(R/L):\t";
					cin >> judge1;
					cin.ignore();
					if (judge1 == 'R' || judge1 == 'r')
						student.registered();
					else if (judge1 == 'L' || judge1 == 'l')
						student.login();
					else
						cout << "无效字符! 请重新输入" << endl;
				}
				break;
			}
			case 'T': {
				while (1) {
					cout << "注册/登录(R/L):\t";
					cin >> judge1;
					cin.ignore();
					if (judge1 == 'R' || judge1 == 'r')
						teacher.registered();
					else if (judge1 == 'L' || judge1 == 'l')
						teacher.login();
					else
						cout << "无效字符! 请重新输入" << endl;
				}
				break;
			}
			case 't': {
				cout << "注册/登录(R/L):\t";
				cin >> judge1;
				cin.ignore();
				if (judge1 == 'R' || judge1 == 'r')
					teacher.registered();
				else if (judge1 == 'L' || judge1 == 'l')
					teacher.login();
				break;
			}
			case 'A': {
				manager.login();
				break;
			}
			case 'a': {
				manager.login();
				break;
			}
			default: {
				cout << "无效字符!请重新输入!" << endl;
				break;
			}
		}
	}
	return 0;
}

```
## struct.h
```
#ifndef STRUCT_H
#define STRUCT_H

//书籍信息结构体
struct book {
	char book_name[25];
	char book_location[25];
	char book_author[15];
	int book_num = 1;
};

//学生信息结构体
struct students {
	char name[10];
	long long ID;
	char password[10];
	char ownbook_name[15];

};

//教师信息结构体
struct teachers {
	char name[10];
	long long ID;
	char password[10];
	char ownbook_name[15];

};

//管理员信息结构体
struct admins {
	char name[10];
	long long ID;
	char password[10];
};

//馆长信息结构体
struct directors {
	char ID[10];
	char password[10];
};
#endif
```
## basic.h
```
#ifndef BASIC_H
#define BASIC_H
#include <cstring>
#include "struct.h"

#include "manage.h"	//使用友元函数必须？
class Basic {
	protected:
		char *book_name;
		char *book_location;
		char *book_author;
		int book_num;
	public:
		Basic() {};
		~Basic() {
			delete[] book_name;
			delete[] book_location;
			delete[] book_author;
		}
		void booksearch();
};

class Books: public Basic {
	private:

	public:
		Books() {}
		~Books() {
			delete []book_name;
			delete []book_location;
		}
		friend void Manage::addbook();
		//管理类友元函数添加书籍
};


class Students: public Basic {
	private:
		char *student_name;
		long long student_ID;
		char *student_password;
		char *ownbook_name;

	public:
		Students() {
			ownbook_name = new char[10];
			strcpy(ownbook_name, "-No Book-");
		}
		~Students() {	//析构函数，释放空间
			delete []student_name;
			delete []ownbook_name;
		}
		void registered();
		//学生注册
		void login();
		//学生登录
		void choose();
		//选择功能
		void borrow();
		//借书
		void repay();
		//还书
};

class Teachers: public Basic {
	private:
		char *teacher_name;
		long long teacher_ID;
		char *teacher_password;
		char *ownbook_name;

	public:
		Teachers() {
			ownbook_name = new char[10];
			strcpy(ownbook_name, "-No Book-");
		}
		~Teachers() {
			delete []teacher_name;
			delete []ownbook_name;
		}
		void registered();
		//教师注册
		void login();
		//教师登录
		void choose();
		//选择功能
		void borrow();
		//借书
		void repay();
		//还书
};

#endif
```
## basic.cpp
```
#include <iostream>
#include <fstream>
#include <cstring>
#include <cmath>
#include "basic.h"
using namespace std;

//*******************************************************************************************************
//搜索书籍信息
void Basic::booksearch() {
	fstream read;
	book searching;
	int m = 0;
	//用于判断是否存在此书籍
	while (m == 0) {	//当此书籍不存在时 循环输入
		read.open("books.dat", ios::in | ios::binary);
		cout << "请输入想查找的图书名:\t";
		char s[25];
		cin.getline(s, 25);
		book_name = new char[strlen(s) + 1];
		strcpy(book_name, s);
		while (!read.eof()) {
			if (!read)
				break;
			read.read((char *)&searching, sizeof(searching));
			if (!strcmp(book_name, searching.book_name)) {
				m = 1;
				cout << "书籍名称:\t" << searching.book_name << endl;
				cout << "书籍作者:\t" << searching.book_author << endl;
				cout << "书籍位置:\t" << searching.book_location << endl;
				cout << "剩余数量:\t" << searching.book_num << endl;
				break;	//无break时，在搜索文件中最后一个书籍时会输出两次
			}
		}
		read.close();
		//*****注意关闭文件！未关闭文件时指针一直在文件结尾*****
		if (m == 0) {
			cout << "书籍不存在!请重新输入!" << endl;
		}
	}
}

//*******************************************************************************************************
//学生注册
void Students::registered() {

	fstream write;	//将学生注册信息写入文件
	write.open("students_info.dat", ios::app | ios::binary);
	students registered;
	cout << "请输入您的姓名:\t";
	cin.getline(registered.name, 10);
	cout << "请输入您的学号:\t";
	cin >> registered.ID;
	cin.ignore();
	cout << "请输入密码:\t";
	cin.getline(registered.password, 10);
	char password[10];
	cout << "请确认密码:\t";
	cin.getline(password, 10);
	if (!strcmp(password, registered.password)) {
		write.write((char *)&registered, sizeof(registered));
		write.close();
		cout << "注册成功!" << endl;
	} else {
		while (strcmp(password, registered.password)) {
			cout << "两次密码输入不一致 请重新输入:\t";
			cin.getline(password, 10);

		}
		if (!strcmp(password, registered.password)) {
			write.write((char *)&registered, sizeof(registered));
			write.close();
			cout << "注册成功!" << endl;
		}
	}
}

//*******************************************************************************************************
//学生登录
void Students::login() {
	fstream read;
	students login;
	int m = 0;
	//用于判断是否存在此用户
	while (m == 0) {	//当用户ID不存在时 循环输入
		read.open("students_info.dat", ios::in | ios::binary);
		cout << "请输入您的学号:\t";
		cin >> student_ID;
		cin.ignore();
		int n = 0;
		//用于判断终止循环
		while (!read.eof()) {
			read.read((char *)&login, sizeof(login));
			if (student_ID == login.ID) {
				m = 1;
				char s[10];
				cout << "请输入密码:\t";

				while (n == 0) {
					cin >> s;
					cin.ignore();
					student_password = new char[strlen(s) + 1];
					strcpy(student_password, s);
					if (!strcmp(student_password, login.password)) {
						n = 1;
						cout << "\n********************************登录成功********************************" << endl;
						student_name = new char[strlen(login.name) + 1];
						strcpy(student_name, login.name);
						cout << login.name << "同学 您好!" << endl;
						cout << "*****个人信息*****" << endl;
						cout << "姓名:\t" << login.name << endl;
						cout << "ID:\t" << login.ID << endl;
						cout << "已借书籍:\t" << login.ownbook_name << endl;
						choose();
					} else {
						cout << "密码错误，请重试!" << endl;
					}
				}
			}
			if (n == 1) {
				break;
			}
			if (!read)
				break;
		}
		if (m == 0) {
			cout << "*************************用户不存在!请重新输入!*************************" << endl;
		}
		read.close();
		//*****注意关闭文件！未关闭文件时指针一直在文件结尾*****
	}
}

//*******************************************************************************************************
//教师注册
void Teachers::registered() {
	fstream write;
	//将教师注册信息写入文件
	write.open("teachers_info.dat", ios::app | ios::binary);
	teachers registered;
	cout << "请输入您的姓名:\t";
	cin.getline(registered.name, 10);
	cout << "请输入您的工号:\t";
	cin >> registered.ID;
	cin.ignore();
	cout << "请输入密码:\t";
	cin.getline(registered.password, 10);
	char password[10];
	cout << "请确认密码:\t";
	cin.getline(password, 10);
	if (!strcmp(password, registered.password)) {
		write.write((char *)&registered, sizeof(registered));
		write.close();
		cout << "注册成功!" << endl;
	} else {
		while (strcmp(password, registered.password)) {
			cout << "两次密码输入不一致 请重新输入:\t";
			cin.getline(password, 10);

		}
		if (!strcmp(password, registered.password)) {
			write.write((char *)&registered, sizeof(registered));
			write.close();
			cout << "注册成功!" << endl;
		}
	}
}

//*******************************************************************************************************
//教师登录
void Teachers::login() {
	fstream read;
	teachers login;
	int m = 0;
	//用于判断是否存在此用户
	while (m == 0) {	//当用户ID不存在时 循环输入
		read.open("teachers_info.dat", ios::in | ios::binary);
		cout << "请输入您的学号:\t";
		cin >> teacher_ID;
		cin.ignore();
		int n = 0;
		//用于判断终止循环
		while (!read.eof()) {
			read.read((char *)&login, sizeof(login));
			if (teacher_ID == login.ID) {
				m = 1;
				char s[10];
				cout << "请输入密码:\t";

				while (n == 0) {
					cin >> s;
					cin.ignore();
					teacher_password = new char[strlen(s) + 1];
					strcpy(teacher_password, s);
					if (!strcmp(teacher_password, login.password)) {
						n = 1;
						cout << "\n********************************登录成功********************************" << endl;
						teacher_name = new char[strlen(login.name) + 1];
						strcpy(teacher_name, login.name);
						cout << login.name << "同学 您好!" << endl;
						cout << "*****个人信息*****" << endl;
						cout << "姓名:\t" << login.name << endl;
						cout << "ID:\t" << login.ID << endl;
						cout << "已借书籍:\t" << login.ownbook_name << endl;
						choose();
					} else {
						cout << "密码错误，请重试!" << endl;
					}
				}
			}
			if (n == 1) {
				break;
			}
			if (!read)
				break;
		}
		if (m == 0) {
			cout << "*************************用户不存在!请重新输入!*************************" << endl;
		}
		read.close();
		//*****注意关闭文件！未关闭文件时指针一直在文件结尾*****
	}
}

//*******************************************************************************************************
//学生选择功能
void Students::choose() {
	char judge1;
	//判断功能
	while (1) {
		cout << "请选择:\t1.查找书籍" << endl;
		cout << "       \t2.借阅书籍" << endl;
		cout << "       \t3.归还书籍" << endl;
		cout << "       \t4.修改密码" << endl;
		cout << "       \t0.退出登录" << endl;
		cin >> judge1;
		cin.ignore();
		switch (judge1) {
			case '1': {
				booksearch();
				break;
			}
			case '2': {
				borrow();
				break;
			}
			case '3': {
				repay();
				break;
			}
			case '0': {
				exit(0);
				break;
			}
			default: {

				break;
			}
		}
	}
}

//*******************************************************************************************************
//教师选择功能
void Teachers::choose() {
	char judge1;
	//判断功能
	while (1) {
		cout << "请选择:\t1.查找书籍" << endl;
		cout << "       \t2.借阅书籍" << endl;
		cout << "       \t3.归还书籍" << endl;
		cout << "       \t4.修改密码" << endl;
		cout << "       \t0.退出登录" << endl;
		cin >> judge1;
		cin.ignore();
		switch (judge1) {
			case '1': {
				booksearch();
				break;
			}
			case '2': {
				borrow();
				break;
			}
			case '3': {
				repay();
				break;
			}
			case '6': {
				exit(0);
				break;
			}
		}
	}
}

//*******************************************************************************************************
//学生借书函数
void Students::borrow() {
	fstream writefile;
	fstream readfile1;
	//读取books.dat
	fstream readfile2;
	//读取books_copy.dat
	book borrow;
	book mid1;
	//读取文件，遍历结构体中的书籍名
	book mid2;
	//读取文件，存储非添加书籍的结构体
	students add_ownbook;
	//在文件里添加借阅书籍信息
	for (int i = 0;; i++) {
		int m = 0;
		//判断书籍是否已存在
		cout << "请输入要借阅的书籍名:\t";
		cin >> borrow.book_name;
		cin.ignore();
		readfile1.open("books.dat", ios::in | ios::binary);
		while (!readfile1.eof()) {
			if (!readfile1)
				break;
			readfile1.read((char *)&mid1, sizeof mid1);
			if ((strcmp(mid1.book_name, borrow.book_name) == 0) && (mid1.book_num != 0)) {
				cout << "馆内现有《" << mid1.book_name << "》" << mid1.book_num << "本" << endl;
				m = 1;
				cout << "*****书籍信息*****\n" << endl;
				cout << "书籍名称:\t" << mid1.book_name << endl;
				cout << "书籍作者:\t" << mid1.book_author << endl;
				cout << "书籍位置:\t" << mid1.book_location << endl;
				cout << "是否确定借阅？(Y/N)" << endl;
				char judge;
				//判断是否确定借阅
				while (1) {
					int n = 0;
					//判断什么时候跳出此while循环
					cin >> judge;
					cin.ignore();
					switch (judge) {
						case 'Y': {
							n = 1;
							fstream borrow_read;
							fstream borrow_write;
							borrow_read.open("students_info.dat", ios::in | ios::binary);
							while (!borrow_read.eof()) {
								if (!borrow_read)
									break;
								borrow_read.read((char *)&add_ownbook, sizeof add_ownbook);
								if (add_ownbook.ID == student_ID) {
									strcpy(add_ownbook.ownbook_name, borrow.book_name);
									borrow_write.open("students_info_copy.dat", ios::out | ios::binary);
									borrow_write.write((char *)&add_ownbook, sizeof add_ownbook);
									borrow_write.close();
								}
							}
							borrow_read.close();
							borrow_read.open("students_info.dat", ios::in | ios::binary);
							while (!borrow_read.eof()) {
								if (!borrow_read)
									break;
								borrow_read.read((char *)&add_ownbook, sizeof add_ownbook);
								if (add_ownbook.ID != student_ID) {
									borrow_write.open("students_info_copy.dat", ios::app | ios::binary);
									borrow_write.write((char *)&add_ownbook, sizeof add_ownbook);
									borrow_write.close();
								}
							}
							borrow_read.close();
							borrow_read.open("students_info.dat", ios::out);
							borrow_read.close();
							borrow_read.open("students_info_copy.dat", ios::in | ios::binary);
							while (!borrow_read.eof()) {
								if (!borrow_read)
									break;
								borrow_read.read((char *)&add_ownbook, sizeof add_ownbook);
								borrow_write.open("students_info.dat", ios::app | ios::binary);
								borrow_write.write((char *)&add_ownbook, sizeof add_ownbook);
								borrow_write.close();
							}
							borrow_read.close();
							mid1.book_num--;
							writefile.open("books_copy.dat", ios::out | ios::binary);
							writefile.write((char *)&mid1, sizeof mid1);
							writefile.clear();
							writefile.close();
							break;
						}
						case 'y': {
							n = 1;
							fstream borrow_read;
							fstream borrow_write;
							borrow_read.open("students_info.dat", ios::in | ios::binary);
							while (!borrow_read.eof()) {
								if (!borrow_read)
									break;
								borrow_read.read((char *)&add_ownbook, sizeof add_ownbook);
								if (add_ownbook.ID == student_ID) {
									strcpy(add_ownbook.ownbook_name, borrow.book_name);
									borrow_write.open("students_info_copy.dat", ios::out | ios::binary);
									borrow_write.write((char *)&add_ownbook, sizeof add_ownbook);
									borrow_write.close();
								}
							}
							borrow_read.close();
							borrow_read.open("students_info.dat", ios::in | ios::binary);
							while (!borrow_read.eof()) {
								if (!borrow_read)
									break;
								borrow_read.read((char *)&add_ownbook, sizeof add_ownbook);
								if (add_ownbook.ID != student_ID) {
									borrow_write.open("students_info_copy.dat", ios::app | ios::binary);
									borrow_write.write((char *)&add_ownbook, sizeof add_ownbook);
									borrow_write.close();
								}
							}
							borrow_read.close();
							borrow_read.open("students_info.dat", ios::out);
							borrow_read.close();
							borrow_read.open("students_info_copy.dat", ios::in | ios::binary);
							while (!borrow_read.eof()) {
								if (!borrow_read)
									break;
								borrow_read.read((char *)&add_ownbook, sizeof add_ownbook);
								borrow_write.open("students_info.dat", ios::app | ios::binary);
								borrow_write.write((char *)&add_ownbook, sizeof add_ownbook);
								borrow_write.close();
							}
							borrow_read.close();
							mid1.book_num--;
							writefile.open("books_copy.dat", ios::out | ios::binary);
							writefile.write((char *)&mid1, sizeof mid1);
							writefile.clear();
							writefile.close();
							break;
						}
						case 'N': {
							n = 1;
							break;
						}
						case 'n': {
							n = 1;
							break;
						}
						default: {
							cout << "无效字符! 请重新输入:\t";
							break;
						}
					}
					if (n == 1)
						break;
				}
				break;
			}
		}
		readfile1.close();
		//*****注意关闭文件！未关闭文件时指针一直在文件结尾*****
		if (m == 1) {
			readfile1.open("books.dat", ios::in | ios::binary);
			while (!readfile1.eof()) {
				if (!readfile1)
					break;
				readfile1.read((char *)&mid2, sizeof mid2);
				if (strcmp(mid2.book_name, borrow.book_name)) {
					writefile.open("books_copy.dat", ios::app | ios::binary);
					writefile.write((char *)&mid2, sizeof mid2);
					writefile.clear();
					writefile.close();
				}
			}
			readfile1.close();
			readfile1.open("books.dat", ios::out);
			readfile1.close();
			readfile2.open("books_copy.dat", ios::in | ios::binary);
			while (!readfile2.eof()) {
				if (!readfile2)
					break;
				readfile2.read((char *)&mid2, sizeof mid2);
				writefile.open("books.dat", ios::app | ios::binary);
				writefile.write((char *)&mid2, sizeof mid2);
				writefile.clear();
				writefile.close();
			}
			readfile2.close();
		}

		else if (m == 0) {	//馆内暂无该书籍时
			cout << "馆内暂无《" << borrow.book_name << "》" << endl;
		}
		cout << "是否要继续借阅(Y/N):\t";
		char judge1;
		//判断是否进行下一次添加
		int judge2 = 1;
		//判断输入字符有效性
		while (judge2) {
			cin >> judge1;
			cin.ignore();
			if (judge1 == 'Y' || judge1 == 'y')
				judge2 = 0;
			else if (judge1 == 'N' || judge1 == 'n')
				judge2 = 0;
			else
				cout << "输入错误，请重新输入:\n";
		}
		if (judge1 == 'Y' || judge1 == 'y')
			continue;
		else if (judge1 == 'N' || judge1 == 'n')
			break;
	}
}

//*******************************************************************************************************
//教师借书函数
void Teachers::borrow() {
	fstream writefile;
	fstream readfile1;
	//读取books.dat
	fstream readfile2;
	//读取books_copy.dat
	book borrow;
	book mid1;
	//读取文件，遍历结构体中的书籍名
	book mid2;
	//读取文件，存储非添加书籍的结构体
	teachers add_ownbook;
	//在文件里添加借阅书籍信息
	for (int i = 0;; i++) {
		int m = 0;
		//判断书籍是否已存在
		cout << "请输入要借阅的书籍名:\t";
		cin >> borrow.book_name;
		cin.ignore();
		readfile1.open("books.dat", ios::in | ios::binary);
		while (!readfile1.eof()) {
			if (!readfile1)
				break;
			readfile1.read((char *)&mid1, sizeof mid1);
			if ((strcmp(mid1.book_name, borrow.book_name) == 0) && (mid1.book_num != 0)) {
				cout << "馆内现有《" << mid1.book_name << "》" << mid1.book_num << "本" << endl;
				m = 1;
				cout << "*****书籍信息*****\n" << endl;
				cout << "书籍名称:\t" << mid1.book_name << endl;
				cout << "书籍作者:\t" << mid1.book_author << endl;
				cout << "书籍位置:\t" << mid1.book_location << endl;
				cout << "是否确定借阅？(Y/N)" << endl;
				char judge;
				//判断是否确定借阅
				while (1) {
					int n = 0;
					//判断什么时候跳出此while循环
					cin >> judge;
					cin.ignore();
					switch (judge) {
						case 'Y': {
							n = 1;
							fstream borrow_read;
							fstream borrow_write;
							borrow_read.open("teachers_info.dat", ios::in | ios::binary);
							while (!borrow_read.eof()) {
								if (!borrow_read)
									break;
								borrow_read.read((char *)&add_ownbook, sizeof add_ownbook);
								if (add_ownbook.ID == teacher_ID) {
									strcpy(add_ownbook.ownbook_name, borrow.book_name);
									borrow_write.open("teachers_info_copy.dat", ios::out | ios::binary);
									borrow_write.write((char *)&add_ownbook, sizeof add_ownbook);
									borrow_write.close();
								}
							}
							borrow_read.close();
							borrow_read.open("teachers_info.dat", ios::in | ios::binary);
							while (!borrow_read.eof()) {
								if (!borrow_read)
									break;
								borrow_read.read((char *)&add_ownbook, sizeof add_ownbook);
								if (add_ownbook.ID != teacher_ID) {
									borrow_write.open("teachers_info_copy.dat", ios::app | ios::binary);
									borrow_write.write((char *)&add_ownbook, sizeof add_ownbook);
									borrow_write.close();
								}
							}
							borrow_read.close();
							borrow_read.open("teachers_info.dat", ios::out);
							borrow_read.close();
							borrow_read.open("teachers_info_copy.dat", ios::in | ios::binary);
							while (!borrow_read.eof()) {
								if (!borrow_read)
									break;
								borrow_read.read((char *)&add_ownbook, sizeof add_ownbook);
								borrow_write.open("teachers_info.dat", ios::app | ios::binary);
								borrow_write.write((char *)&add_ownbook, sizeof add_ownbook);
								borrow_write.close();
							}
							borrow_read.close();
							mid1.book_num--;
							writefile.open("books_copy.dat", ios::out | ios::binary);
							writefile.write((char *)&mid1, sizeof mid1);
							writefile.clear();
							writefile.close();
							break;
						}
						case 'y': {

							break;
						}
						case 'N': {
							n = 1;
							break;
						}
						case 'n': {
							n = 1;
							break;
						}
						default: {
							cout << "无效字符! 请重新输入:\t";
							break;
						}
					}
					if (n == 1)
						break;
				}
				break;
			}
		}
		readfile1.close();
		//*****注意关闭文件！未关闭文件时指针一直在文件结尾*****
		if (m == 1) {
			readfile1.open("books.dat", ios::in | ios::binary);
			while (!readfile1.eof()) {
				if (!readfile1)
					break;
				readfile1.read((char *)&mid2, sizeof mid2);
				if (strcmp(mid2.book_name, borrow.book_name)) {
					writefile.open("books_copy.dat", ios::app | ios::binary);
					writefile.write((char *)&mid2, sizeof mid2);
					writefile.clear();
					writefile.close();
				}
			}
			readfile1.close();
			readfile1.open("books.dat", ios::out);
			readfile1.close();
			readfile2.open("books_copy.dat", ios::in | ios::binary);
			while (!readfile2.eof()) {
				if (!readfile2)
					break;
				readfile2.read((char *)&mid2, sizeof mid2);
				writefile.open("books.dat", ios::app | ios::binary);
				writefile.write((char *)&mid2, sizeof mid2);
				writefile.clear();
				writefile.close();
			}
			readfile2.close();
		}

		else if (m == 0) {	//馆内暂无该书籍时
			cout << "馆内暂无《" << borrow.book_name << "》" << endl;
		}
		cout << "是否要继续借阅(Y/N):\t";
		char judge1;
		//判断是否进行下一次添加
		int judge2 = 1;
		//判断输入字符有效性
		while (judge2) {
			cin >> judge1;
			cin.ignore();
			if (judge1 == 'Y' || judge1 == 'y')
				judge2 = 0;
			else if (judge1 == 'N' || judge1 == 'n')
				judge2 = 0;
			else
				cout << "输入错误，请重新输入:\n";
		}
		if (judge1 == 'Y' || judge1 == 'y')
			continue;
		else if (judge1 == 'N' || judge1 == 'n')
			break;
	}
}

//*******************************************************************************************************
//学生还书
void Students::repay() {
	fstream readfile1;
	fstream readfile2;
	fstream writefile;
	book reply;
	book mid1;
	book mid2;
	students del_ownbook;
	for (int i = 0;; i++) {
		int m = 0;
		//判断书籍是否已存在
		cout << "请输入要归还的书籍名:\t";
		cin >> reply.book_name;
		cin.ignore();
		readfile1.open("books.dat", ios::in | ios::binary);
		while (!readfile1.eof()) {
			if (!readfile1)
				break;
			readfile1.read((char *)&mid1, sizeof mid1);
			if (strcmp(mid1.book_name, reply.book_name) == 0) {
				cout << "馆内现有《" << mid1.book_name << "》" << mid1.book_num << "本" << endl;
				m = 1;
				cout << "*****书籍信息*****\n" << endl;
				cout << "书籍名称:\t" << mid1.book_name << endl;
				cout << "书籍作者:\t" << mid1.book_author << endl;
				cout << "书籍位置:\t" << mid1.book_location << endl;
				cout << "是否确定归还？(Y/N)" << endl;
				char judge;
				//判断是否确定归还
				while (1) {
					int n = 0;
					//判断什么时候跳出此while循环
					cin >> judge;
					cin.ignore();
					switch (judge) {
						case 'Y': {
							n = 1;
							fstream reply_read;
							fstream reply_write;
							reply_read.open("students_info.dat", ios::in | ios::binary);
							while (!reply_read.eof()) {
								if (!reply_read)
									break;
								reply_read.read((char *)&del_ownbook, sizeof del_ownbook);
								if (del_ownbook.ID == student_ID) {
									strcpy(del_ownbook.ownbook_name, "No Book");
									reply_write.open("students_info_copy.dat", ios::out | ios::binary);
									reply_write.write((char *)&del_ownbook, sizeof del_ownbook);
									reply_write.close();
								}
							}
							reply_read.close();
							reply_read.open("students_info.dat", ios::in | ios::binary);
							while (!reply_read.eof()) {
								if (!reply_read)
									break;
								reply_read.read((char *)&del_ownbook, sizeof del_ownbook);
								if (del_ownbook.ID != student_ID) {
									reply_write.open("students_info_copy.dat", ios::app | ios::binary);
									reply_write.write((char *)&del_ownbook, sizeof del_ownbook);
									reply_write.close();
								}
							}
							reply_read.close();
							reply_read.open("students_info.dat", ios::out);
							reply_read.close();
							reply_read.open("students_info_copy.dat", ios::in | ios::binary);
							while (!reply_read.eof()) {
								if (!reply_read)
									break;
								reply_read.read((char *)&del_ownbook, sizeof del_ownbook);
								reply_write.open("students_info.dat", ios::app | ios::binary);
								reply_write.write((char *)&del_ownbook, sizeof del_ownbook);
								reply_write.close();
							}
							reply_read.close();
							mid1.book_num++;
							writefile.open("books_copy.dat", ios::out | ios::binary);
							writefile.write((char *)&mid1, sizeof mid1);
							writefile.clear();
							writefile.close();
							break;
						}
						case 'y': {
							n = 1;
							fstream reply_read;
							fstream reply_write;
							reply_read.open("students_info.dat", ios::in | ios::binary);
							while (!reply_read.eof()) {
								if (!reply_read)
									break;
								reply_read.read((char *)&del_ownbook, sizeof del_ownbook);
								if (del_ownbook.ID == student_ID) {
									strcpy(del_ownbook.ownbook_name, "No Book");
									reply_write.open("students_info_copy.dat", ios::out | ios::binary);
									reply_write.write((char *)&del_ownbook, sizeof del_ownbook);
									reply_write.close();
								}
							}
							reply_read.close();
							reply_read.open("students_info.dat", ios::in | ios::binary);
							while (!reply_read.eof()) {
								if (!reply_read)
									break;
								reply_read.read((char *)&del_ownbook, sizeof del_ownbook);
								if (del_ownbook.ID != student_ID) {
									reply_write.open("students_info_copy.dat", ios::app | ios::binary);
									reply_write.write((char *)&del_ownbook, sizeof del_ownbook);
									reply_write.close();
								}
							}
							reply_read.close();
							reply_read.open("students_info.dat", ios::out);
							reply_read.close();
							reply_read.open("students_info_copy.dat", ios::in | ios::binary);
							while (!reply_read.eof()) {
								if (!reply_read)
									break;
								reply_read.read((char *)&del_ownbook, sizeof del_ownbook);
								reply_write.open("students_info.dat", ios::app | ios::binary);
								reply_write.write((char *)&del_ownbook, sizeof del_ownbook);
								reply_write.close();
							}
							reply_read.close();
							mid1.book_num++;
							writefile.open("books_copy.dat", ios::out | ios::binary);
							writefile.write((char *)&mid1, sizeof mid1);
							writefile.clear();
							writefile.close();
							break;
						}
						case 'N': {
							n = 1;
							break;
						}
						case 'n': {
							n = 1;
							break;
						}
						default: {
							cout << "无效字符! 请重新输入:\t";
							break;
						}
					}
					if (n == 1)
						break;
				}
				break;
			}
		}
		readfile1.close();
		//*****注意关闭文件！未关闭文件时指针一直在文件结尾*****
		if (m == 1) {
			readfile1.open("books.dat", ios::in | ios::binary);
			while (!readfile1.eof()) {
				if (!readfile1)
					break;
				readfile1.read((char *)&mid2, sizeof mid2);
				if (strcmp(mid2.book_name, reply.book_name)) {
					writefile.open("books_copy.dat", ios::app | ios::binary);
					writefile.write((char *)&mid2, sizeof mid2);
					writefile.clear();
					writefile.close();
				}
			}
			readfile1.close();
			readfile1.open("books.dat", ios::out);
			readfile1.close();
			readfile2.open("books_copy.dat", ios::in | ios::binary);
			while (!readfile2.eof()) {
				if (!readfile2)
					break;
				readfile2.read((char *)&mid2, sizeof mid2);
				writefile.open("books.dat", ios::app | ios::binary);
				writefile.write((char *)&mid2, sizeof mid2);
				writefile.clear();
				writefile.close();
			}
			readfile2.close();
		}

		cout << "是否要继续归还(Y/N):\t";
		char judge1;
		//判断是否进行下一次添加
		int judge2 = 1;
		//判断输入字符有效性
		while (judge2) {
			cin >> judge1;
			cin.ignore();
			if (judge1 == 'Y' || judge1 == 'y')
				judge2 = 0;
			else if (judge1 == 'N' || judge1 == 'n')
				judge2 = 0;
			else
				cout << "输入错误，请重新输入:\n";
		}
		if (judge1 == 'Y' || judge1 == 'y')
			continue;
		else if (judge1 == 'N' || judge1 == 'n')
			break;
	}
}

//*******************************************************************************************************
//教师还书
void Teachers::repay() {
	fstream readfile1;
	fstream readfile2;
	fstream writefile;
	book reply;
	book mid1;
	book mid2;
	teachers del_ownbook;
	for (int i = 0;; i++) {
		int m = 0;
		//判断书籍是否已存在
		cout << "请输入要归还的书籍名:\t";
		cin >> reply.book_name;
		cin.ignore();
		readfile1.open("books.dat", ios::in | ios::binary);
		while (!readfile1.eof()) {
			if (!readfile1)
				break;
			readfile1.read((char *)&mid1, sizeof mid1);
			if (strcmp(mid1.book_name, reply.book_name) == 0) {
				cout << "馆内现有《" << mid1.book_name << "》" << mid1.book_num << "本" << endl;
				m = 1;
				cout << "*****书籍信息*****\n" << endl;
				cout << "书籍名称:\t" << mid1.book_name << endl;
				cout << "书籍作者:\t" << mid1.book_author << endl;
				cout << "书籍位置:\t" << mid1.book_location << endl;
				cout << "是否确定归还？(Y/N)" << endl;
				char judge;
				//判断是否确定归还
				while (1) {
					int n = 0;
					//判断什么时候跳出此while循环
					cin >> judge;
					cin.ignore();
					switch (judge) {
						case 'Y': {
							n = 1;
							fstream reply_read;
							fstream reply_write;
							reply_read.open("teachers_info.dat", ios::in | ios::binary);
							while (!reply_read.eof()) {
								if (!reply_read)
									break;
								reply_read.read((char *)&del_ownbook, sizeof del_ownbook);
								if (del_ownbook.ID == teacher_ID) {
									strcpy(del_ownbook.ownbook_name, "No Book");
									reply_write.open("teachers_info_copy.dat", ios::out | ios::binary);
									reply_write.write((char *)&del_ownbook, sizeof del_ownbook);
									reply_write.close();
								}
							}
							reply_read.close();
							reply_read.open("teachers_info.dat", ios::in | ios::binary);
							while (!reply_read.eof()) {
								if (!reply_read)
									break;
								reply_read.read((char *)&del_ownbook, sizeof del_ownbook);
								if (del_ownbook.ID != teacher_ID) {
									reply_write.open("teachers_info_copy.dat", ios::app | ios::binary);
									reply_write.write((char *)&del_ownbook, sizeof del_ownbook);
									reply_write.close();
								}
							}
							reply_read.close();
							reply_read.open("teachers_info.dat", ios::out);
							reply_read.close();
							reply_read.open("teachers_info_copy.dat", ios::in | ios::binary);
							while (!reply_read.eof()) {
								if (!reply_read)
									break;
								reply_read.read((char *)&del_ownbook, sizeof del_ownbook);
								reply_write.open("teachers_info.dat", ios::app | ios::binary);
								reply_write.write((char *)&del_ownbook, sizeof del_ownbook);
								reply_write.close();
							}
							reply_read.close();
							mid1.book_num++;
							writefile.open("books_copy.dat", ios::out | ios::binary);
							writefile.write((char *)&mid1, sizeof mid1);
							writefile.clear();
							writefile.close();
							break;
						}
						case 'y': {
							n = 1;
							fstream reply_read;
							fstream reply_write;
							reply_read.open("teachers_info.dat", ios::in | ios::binary);
							while (!reply_read.eof()) {
								if (!reply_read)
									break;
								reply_read.read((char *)&del_ownbook, sizeof del_ownbook);
								if (del_ownbook.ID == teacher_ID) {
									strcpy(del_ownbook.ownbook_name, "No Book");
									reply_write.open("teachers_info_copy.dat", ios::out | ios::binary);
									reply_write.write((char *)&del_ownbook, sizeof del_ownbook);
									reply_write.close();
								}
							}
							reply_read.close();
							reply_read.open("teachers_info.dat", ios::in | ios::binary);
							while (!reply_read.eof()) {
								if (!reply_read)
									break;
								reply_read.read((char *)&del_ownbook, sizeof del_ownbook);
								if (del_ownbook.ID != teacher_ID) {
									reply_write.open("teachers_info_copy.dat", ios::app | ios::binary);
									reply_write.write((char *)&del_ownbook, sizeof del_ownbook);
									reply_write.close();
								}
							}
							reply_read.close();
							reply_read.open("teachers_info.dat", ios::out);
							reply_read.close();
							reply_read.open("teachers_info_copy.dat", ios::in | ios::binary);
							while (!reply_read.eof()) {
								if (!reply_read)
									break;
								reply_read.read((char *)&del_ownbook, sizeof del_ownbook);
								reply_write.open("teachers_info.dat", ios::app | ios::binary);
								reply_write.write((char *)&del_ownbook, sizeof del_ownbook);
								reply_write.close();
							}
							reply_read.close();
							mid1.book_num++;
							writefile.open("books_copy.dat", ios::out | ios::binary);
							writefile.write((char *)&mid1, sizeof mid1);
							writefile.clear();
							writefile.close();
							break;
						}
						case 'N': {
							n = 1;
							break;
						}
						case 'n': {
							n = 1;
							break;
						}
						default: {
							cout << "无效字符! 请重新输入:\t";
							break;
						}
					}
					if (n == 1)
						break;
				}
				break;
			}
		}
		readfile1.close();
		//*****注意关闭文件！未关闭文件时指针一直在文件结尾*****
		if (m == 1) {
			readfile1.open("books.dat", ios::in | ios::binary);
			while (!readfile1.eof()) {
				if (!readfile1)
					break;
				readfile1.read((char *)&mid2, sizeof mid2);
				if (strcmp(mid2.book_name, reply.book_name)) {
					writefile.open("books_copy.dat", ios::app | ios::binary);
					writefile.write((char *)&mid2, sizeof mid2);
					writefile.clear();
					writefile.close();
				}
			}
			readfile1.close();
			readfile1.open("books.dat", ios::out);
			readfile1.close();
			readfile2.open("books_copy.dat", ios::in | ios::binary);
			while (!readfile2.eof()) {
				if (!readfile2)
					break;
				readfile2.read((char *)&mid2, sizeof mid2);
				writefile.open("books.dat", ios::app | ios::binary);
				writefile.write((char *)&mid2, sizeof mid2);
				writefile.clear();
				writefile.close();
			}
			readfile2.close();
		}

		cout << "是否要继续归还(Y/N):\t";
		char judge1;
		//判断是否进行下一次添加
		int judge2 = 1;
		//判断输入字符有效性
		while (judge2) {
			cin >> judge1;
			cin.ignore();
			if (judge1 == 'Y' || judge1 == 'y')
				judge2 = 0;
			else if (judge1 == 'N' || judge1 == 'n')
				judge2 = 0;
			else
				cout << "输入错误，请重新输入:\n";
		}
		if (judge1 == 'Y' || judge1 == 'y')
			continue;
		else if (judge1 == 'N' || judge1 == 'n')
			break;
	}
}
```
## manage.h
```
#ifndef MANAGE_H
#define MANAGE_H

#include "struct.h"
class Manage {
	protected:

	public:
		~Manage() {}
		void addbook();
		void login();
		void searchperson();
};

class Admins: public Manage {
	private:
		char *admin_name;
		char *admin_password;
		long long admin_ID;
	public:
		Admins() {}
		~Admins() {
			delete []admin_name;
			delete []admin_password;
		}
		void choose();

};

class Directors: public Manage {
	private:

	public:
		void addadmin();
		void deladmin();
		void changeID();
		void changepassword();
		void choose();
};

#endif
```
## manage.cpp
```c++
#include <iostream>
#include <fstream>
#include <cstring>
#include <cmath>
#include <stdlib.h>
#include "manage.h"
#include "basic.h"
using namespace std;

//*******************************************************************************************************
//管理者登录
void Manage::login() {
	Admins admin;
	Directors director;
	cout << "*********************************请登录*********************************" << endl;
	cout << "请输入ID:\t";
	char director_ID[10];
	char manage_password[10];

	while (1) {
		cin >> director_ID;
		cin.ignore();
		fstream read;
		directors d_login;
		admins a_login;
		read.open("director_info.dat", ios::in | ios::binary);
		int m = 0;
		//判断用户名是否为馆长ID
		int n = 0;
		//判断馆长是否登录成功
		int o = 0;
		//判断用户名ID是否为管理员ID
		while (!read.eof()) {
			if (!read)
				break;
			read.read((char *)&d_login, sizeof d_login);
			if (!strcmp(director_ID, d_login.ID)) {
				m = 1;
				cout << "请输入馆长密码:\t";
				while (1) {
					cin >> manage_password;
					cin.ignore();
					if (!strcmp(manage_password, d_login.password)) {
						n = 1;
						cout << "\n********************************登录成功********************************" << endl;
						cout << "馆长您好!" << endl;
						director.choose();
						break;
					} else {
						cout << "馆长密码错误! 请重新输入:\t";
						continue;
					}
				}
				if (n == 1)
					break;
			}
			if (m == 0)
				break;
		}
		read.close();
		if (m == 0) {
			long long admin_ID = 0;
			for (int j = 0; j < strlen(director_ID); j++) {
				admin_ID = admin_ID + ((int)director_ID[j] - 48) * pow(10, strlen(director_ID) - j - 1);
			}
			read.open("admins_info.dat", ios::in | ios::binary);
			while (!read.eof()) {
				if (!read)
					break;
				read.read((char *)&a_login, sizeof a_login);
				if (admin_ID == a_login.ID) {
					o = 1;
					cout << "请输入管理员密码:\t";
					while (1) {
						cin >> manage_password;
						cin.ignore();
						if (!strcmp(manage_password, a_login.password)) {
							cout << "\n********************************登录成功********************************" << endl;
							cout << a_login.name << "管理员您好!" << endl;
							admin.choose();
							break;
						} else {
							cout << "管理员密码错误! 请重新输入:\t";
							continue;
						}
					}
				}
			}
		}
		if (m == 0 && o == 0) {
			cout << "此管理不存在! 请重新输入:\t";
			continue;
		}
	}
}


//*******************************************************************************************************
//馆长选择功能
void Directors::choose() {
	Basic basic;
	char judge2;	//选择功能
	while (1) {
		cout << "\n请选择:1.-----查找书籍" << endl;
		cout << "       2.-----添加书籍" << endl;
		cout << "       3.-----查找学生/教师" << endl;
		cout << "       4.-----添加管理员" << endl;
		cout << "       5.-----删除管理员" << endl;
		cout << "       6.-----修改登录名" << endl;
		cout << "       7.-----修改密码" << endl;
		cout << "       0.-----退出登录" << endl;
		cin >> judge2;
		cin.ignore();
		switch (judge2) {
			case '1': {
				basic.booksearch();
				break;
			}
			case '2': {
				addbook();
				break;
			}
			case '3': {
				searchperson();
				break;
			}
			case '4': {
				addadmin();
				break;
			}
			case '5': {
				deladmin();
				break;
			}
			case '6': {

				break;
			}
			case '0': {
				exit(0);
				break;
			}
			default: {
				cout << "输入字符无效!请重新输入!" << endl;
				break;
			}
		}
	}

}

//*******************************************************************************************************
//管理员选择功能
void Admins::choose() {
	Basic basic;
	char judge2;	//选择功能
	while (1) {
		cout << "\n请选择:\t1.-----查找书籍" << endl;
		cout << "       \t2.-----查找学生/教师信息" << endl;
		cout << "       \t3.-----修改登录名" << endl;
		cout << "       \t4.-----修改密码" << endl;
		cout << "       \t0.-----退出登录" << endl;
		cin >> judge2;
		cin.ignore();
		switch (judge2) {
			case '1': {
				basic.booksearch();
				break;
			}
			case '2': {
				searchperson();
				break;
			}
			case '3': {

				break;
			}
			case '0': {
				exit(0);
				break;
			}
			default: {
				cout << "输入字符无效!请重新输入!" << endl;
				break;
			}
		}
	}
}

//*******************************************************************************************************
//管理者添加书籍
void Manage::addbook() {
	fstream writefile;
	fstream readfile0;
	//验证books.dat是否存在
	fstream readfile1;
	//读取books.dat
	fstream readfile2;
	//读取books_copy.dat
	book adding;
	book mid1;
	//读取文件，遍历结构体中的书籍名
	book mid2;
	//读取文件，存储非添加书籍的结构体

	readfile0.open("books.dat", ios::in);
	//当books.dat不存在时，新建文件
	if (!readfile0) {
		readfile1.open("books.dat", ios::out);
		cout << "books.dat创建成功!" << endl;
		readfile1.close();
	}
	readfile0.close();

	for (int i = 0;; i++) {
		int m = 0;
		//判断书籍是否已存在
		cout << "请输入要添加的书籍名:\t";
		cin >> adding.book_name;
		cin.ignore();
		readfile1.open("books.dat", ios::in | ios::binary);
		while (!readfile1.eof()) {
			if (!readfile1)
				break;
			readfile1.read((char *)&mid1, sizeof mid1);
			if (strcmp(mid1.book_name, adding.book_name) == 0) {
				cout << "馆内已存在此书籍" << endl;
				m = 1;
				mid1.book_num++;
				cout << "书籍名称:\t" << mid1.book_name << endl;
				cout << "书籍作者:\t" << mid1.book_author << endl;
				cout << "书籍位置:\t" << mid1.book_location << endl;
				cout << "剩余数量:\t" << mid1.book_num << endl;
				writefile.open("books_copy.dat", ios::out | ios::binary);
				writefile.write((char *)&mid1, sizeof mid1);
				writefile.clear();
				writefile.close();
				break;
			}
		}
		readfile1.close();
		//*****注意关闭文件！未关闭文件时指针一直在文件结尾*****

		if (m == 1) {
			readfile1.open("books.dat", ios::in | ios::binary);
			while (!readfile1.eof()) {
				if (!readfile1)
					break;
				readfile1.read((char *)&mid2, sizeof mid2);
				if (strcmp(mid2.book_name, adding.book_name) != 0) {
					writefile.open("books_copy.dat", ios::app | ios::binary);
					writefile.write((char *)&mid2, sizeof mid2);
					writefile.clear();
					writefile.close();

				}
			}
			readfile1.close();

			readfile1.open("books.dat", ios::out);
			readfile1.close();
			readfile2.open("books_copy.dat", ios::in | ios::binary);
			while (!readfile2.eof()) {
				if (!readfile2)
					break;
				readfile2.read((char *)&mid2, sizeof mid2);
				writefile.open("books.dat", ios::app | ios::binary);
				writefile.write((char *)&mid2, sizeof mid2);
				writefile.clear();
				writefile.close();
			}
			readfile2.close();
		}

		else if (m == 0) {	//馆内未添加该书籍时
			writefile.open("books.dat", ios::app | ios::binary);
			cout << "请输入要添加的书籍作者:\t";
			cin.getline(adding.book_author, 15);
			cout << "请输入要添加的书籍所放位置:\t";
			cin.getline(adding.book_location, 25);
			writefile.write((char *)&adding, sizeof(adding));
			writefile.clear();
			writefile.close();
		}
		cout << "是否要继续添加(Y/N):\t";
		char judge1;
		//判断是否进行下一次添加
		int judge2 = 1;
		//判断输入字符有效性
		while (judge2) {
			cin >> judge1;
			cin.ignore();
			if (judge1 == 'Y' || judge1 == 'y')
				judge2 = 0;
			else if (judge1 == 'N' || judge1 == 'n')
				judge2 = 0;
			else
				cout << "输入错误，请重新输入:\n";
		}
		if (judge1 == 'Y' || judge1 == 'y')
			continue;
		else if (judge1 == 'N' || judge1 == 'n')
			break;
	}
}

//*******************************************************************************************************
//馆长添加管理员
void Directors::addadmin() {
	fstream write;
	//将管理员信息写入文件
	write.open("admins_info.dat", ios::app | ios::binary);
	admins add;
	cout << "请输入添加的管理员姓名:\t";
	cin >> add.name;
	cin.ignore();
	cout << "请输入添加的管理员ID:\t";
	cin >> add.ID;
	cout << "请为添加的管理员初始化密码:\t";
	cin >> add.password;
	cin.ignore();
	char password[10];
	cout << "请确认密码:\t";
	cin >> password;
	cin.ignore();
	if (strcmp(password, add.password) == 0) {
		write.write((char *)&add, sizeof(add));
		write.close();
		cout << "注册成功!" << endl;
	} else {
		while (strcmp(password, add.password) != 0) {
			cout << "两次密码输入不一致 请重新输入:\t";
			cin >> password;
			cin.ignore();
		}
		if (!strcmp(password, add.password)) {
			write.write((char *)&add, sizeof(add));
			write.close();
			cout << "注册成功!" << endl;
		}
	}
}
//*******************************************************************************************************
//馆长删除管理员
void Directors::deladmin() {
	admins del;
	fstream read;
	fstream write;
	long long mid1;
	cout << "请输入要删除的管理员ID:\t";
	cin >> mid1;
	read.open("admins_info.dat", ios::in | ios::binary);
	while (!read.eof()) {
		if (!read)
			break;
		read.read((char *)&del, sizeof del);
		if (mid1 == del.ID) {
			write.open("admins_info_copy.dat", ios::out);
			write.close();
		}
	}
	read.close();
	read.open("admins_info.dat", ios::in | ios::binary);
	while (!read.eof()) {
		if (!read)
			break;
		read.read((char *)&del, sizeof del);
		if (mid1 != del.ID) {
			write.open("admins_info_copy.dat", ios::app | ios::binary);
			write.write((char *)&del, sizeof del);
			write.close();
		}
	}
	read.close();
	write.open("admins_info.dat", ios::out);
	write.close();
	read.open("admins_info_copy.dat", ios::in | ios::binary);
	while (!read.eof()) {
		if (!read)
			break;
		read.read((char *)&del, sizeof del);
		write.open("admins_info.dat", ios::app | ios::binary);
		write.write((char *)&del, sizeof del);
		write.close();
	}
	read.close();
}

//*******************************************************************************************************
//查找学生/教师信息
void Manage::searchperson() {
	char judge1;
	cout << "请选择查找的人物身份(S/s-学生 T/t-教师):\t";
	cin >> judge1;
	cin.ignore();
	if (judge1 == 'S' || judge1 == 's') {
		cout << "请输入查找方式:\t1.---姓名" << endl;
		cout << "               \t2.---ID" << endl;
		char judge2;
		int judge3 = 0;
		cin >> judge2;
		switch (judge2) {
			case '1': {
				students search;
				char name[10];
				do {
					cout << "请输入查找的学生姓名:\t";
					cin >> name;
					cin.ignore();
					fstream read;
					read.open("students_info.dat", ios::in | ios::binary);
					while (!read.eof()) {
						if (!read)
							break;
						read.read((char *)&search, sizeof search);
						if (!strcmp(search.name, name)) {
							judge3 = 1;
							cout << "学生姓名:      " << search.name << endl;
							cout << "学生ID:        " << search.ID << endl;
							cout << "学生所借书籍:  " << search.ownbook_name << endl;
							break;
						}
					}
					read.close();
					if (judge3 == 0) {
						cout << "未找到用户 " << name << "同学" << endl;
						continue;
					}
				} while (0);
				break;
			}
			case '2': {
				students search;
				long long ID;
				do {
					cout << "请输入查找的学生ID:\t";
					cin >> ID;
					fstream read;
					read.open("students_info.dat", ios::in | ios::binary);
					while (!read.eof()) {
						if (!read)
							break;
						read.read((char *)&search, sizeof search);
						if (search.ID == ID) {
							judge3 = 1;
							cout << "学生姓名:      " << search.name << endl;
							cout << "学生ID:        " << search.ID << endl;
							cout << "学生所借书籍:  " << search.ownbook_name << endl;
							break;
						}
					}
					read.close();
					if (judge3 == 0) {
						cout << "未找到用户ID为 " << ID << " 的同学" << endl;
						continue;
					}
				} while (0);
				break;
			}
			default: {
				cout << "无效字符! 请重新输入:" << endl;
				break;
			}
		}
	} else if (judge1 == 'T' || judge1 == 't') {
		cout << "请输入查找方式:\t1.---姓名" << endl;
		cout << "               \t2.---ID" << endl;
		char judge2;
		int judge3 = 0;
		cin >> judge2;
		switch (judge2) {
			case '1': {
				teachers search;
				char name[10];
				while (1) {
					cout << "请输入查找的教师姓名:\t";
					cin >> name;
					cin.ignore();
					fstream read;
					read.open("teachers_info.dat", ios::in | ios::binary);
					while (!read.eof()) {
						if (!read)
							break;
						read.read((char *)&search, sizeof search);
						if (!strcmp(search.name, name)) {
							judge3 = 1;
							cout << "教师姓名:      " << search.name << endl;
							cout << "教师ID:        " << search.ID << endl;
							cout << "教师所借书籍:  " << search.ownbook_name << endl;
							break;
						}
					}
					read.close();
					if (judge3 == 0) {
						cout << "未找到用户 " << name << "同学" << endl;
						continue;
					}
				}
				break;
			}
			case '2': {
				teachers search;
				long long ID;
				do {
					cout << "请输入查找的教师ID:\t";
					cin >> ID;
					fstream read;
					read.open("teachers_info.dat", ios::in | ios::binary);
					while (!read.eof()) {
						if (!read)
							break;
						read.read((char *)&search, sizeof search);
						if (search.ID == ID) {
							judge3 = 1;
							cout << "教师姓名:      " << search.name << endl;
							cout << "教师ID:        " << search.ID << endl;
							cout << "教师所借书籍:  " << search.ownbook_name << endl;
							break;
						}
					}
					read.close();
					if (judge3 == 0) {
						cout << "未找到用户ID为 " << ID << " 的同学" << endl;
						continue;
					}
				} while (0);
				break;
			}
			default: {
				cout << "无效字符! 请重新输入:" << endl;
				break;
			}
		}
	}
}
```
> 馆长初始登录信息就写个程序写入文件了

## change_director.cpp
```c++
#include<iostream>
#include<fstream>
using namespace std;
struct director{
	char ID[10];
	char password[10];
};
int main(){
	fstream write;
	director registered;
	cout<<"ID:"<<endl;
	cin>>registered.ID;
	cin.ignore();
	cin>>registered.password;
	cin.ignore();
	write.open("director_info.dat",ios::out|ios::binary);
	write.write((char *)&registered,sizeof registered);
	write.close();
	return 0;
}
```

